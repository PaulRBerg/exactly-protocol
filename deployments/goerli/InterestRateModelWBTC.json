{
  "address": "0xe24eD60fe91EC369bFCd26A71365D736a90a1A58",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fixedCurveA_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "fixedCurveB_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "fixedMaxUtilization_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "floatingCurveA_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "floatingCurveB_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "floatingMaxUtilization_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyMatured",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UtilizationExceeded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maturity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "borrowed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "supplied",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "backupAssets",
          "type": "uint256"
        }
      ],
      "name": "fixedBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedCurveA",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedCurveB",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedMaxUtilization",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "utilizationBefore",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "utilizationAfter",
          "type": "uint256"
        }
      ],
      "name": "floatingBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "floatingCurveA",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "floatingCurveB",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "floatingMaxUtilization",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2ef143cc7481ddff74da711d21f6cf9f523068e1fa7edcf5adb8232bcfb17b42",
  "receipt": {
    "to": null,
    "from": "0xDb90CDB64CfF03f254e4015C4F705C3F3C834400",
    "contractAddress": "0xe24eD60fe91EC369bFCd26A71365D736a90a1A58",
    "transactionIndex": 73,
    "gasUsed": "680793",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9e9b76df8f5f352baae4a2297628fac2fc6319e74cf05d54507ec6bd0ac406fc",
    "transactionHash": "0x2ef143cc7481ddff74da711d21f6cf9f523068e1fa7edcf5adb8232bcfb17b42",
    "logs": [],
    "blockNumber": 7851820,
    "cumulativeGasUsed": "11841131",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "1537200000000000000",
    "-1389800000000000000",
    "1086500000000000000",
    "54700000000000000",
    "-33500000000000000",
    "1021600000000000000"
  ],
  "numDeployments": 3,
  "solcInputHash": "caf04502d09415a51d794c069d7c8705",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fixedCurveA_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"fixedCurveB_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"fixedMaxUtilization_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floatingCurveA_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"floatingCurveB_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"floatingMaxUtilization_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyMatured\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UtilizationExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"backupAssets\",\"type\":\"uint256\"}],\"name\":\"fixedBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedCurveA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedCurveB\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedMaxUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"utilizationBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationAfter\",\"type\":\"uint256\"}],\"name\":\"floatingBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floatingCurveA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floatingCurveB\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floatingMaxUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)\":{\"params\":{\"amount\":\"the current borrow's amount.\",\"backupAssets\":\"backup supplier assets.\",\"borrowed\":\"ex-ante amount borrowed from this fixed rate pool.\",\"maturity\":\"maturity date for calculating days left to maturity.\",\"supplied\":\"deposits in the fixed rate pool.\"},\"returns\":{\"_0\":\"rate of the fee that the borrower will have to pay (represented with 18 decimals).\"}},\"floatingBorrowRate(uint256,uint256)\":{\"details\":\"Minimum and maximum checks to avoid negative rate.\",\"params\":{\"utilizationAfter\":\"ex-post utilization rate, with 18 decimals precision.\",\"utilizationBefore\":\"ex-ante utilization rate, with 18 decimals precision.\"},\"returns\":{\"_0\":\"the interest rate, with 18 decimals precision.\"}}},\"stateVariables\":{\"PRECISION_THRESHOLD\":{\"details\":\"When `eta` (`delta / alpha`) is lower than this value, use simpson's rule for approximation.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the rate to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate pool and assets from the backup supplier.\"},\"fixedCurveA()\":{\"notice\":\"Scale factor of the fixed curve.\"},\"fixedCurveB()\":{\"notice\":\"Origin intercept of the fixed curve.\"},\"fixedMaxUtilization()\":{\"notice\":\"Asymptote of the fixed curve.\"},\"floatingBorrowRate(uint256,uint256)\":{\"notice\":\"Returns the interest rate integral from utilizationBefore to utilizationAfter.\"},\"floatingCurveA()\":{\"notice\":\"Scale factor of the floating curve.\"},\"floatingCurveB()\":{\"notice\":\"Origin intercept of the floating curve.\"},\"floatingMaxUtilization()\":{\"notice\":\"Asymptote of the floating curve.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/InterestRateModel.sol\":\"InterestRateModel\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\ncontract InterestRateModel {\\n  using FixedPointMathLib for uint256;\\n  using FixedPointMathLib for int256;\\n\\n  /// @notice Threshold to define which method should be used to calculate the interest rates.\\n  /// @dev When `eta` (`delta / alpha`) is lower than this value, use simpson's rule for approximation.\\n  uint256 internal constant PRECISION_THRESHOLD = 7.5e14;\\n\\n  /// @notice Scale factor of the fixed curve.\\n  uint256 public immutable fixedCurveA;\\n  /// @notice Origin intercept of the fixed curve.\\n  int256 public immutable fixedCurveB;\\n  /// @notice Asymptote of the fixed curve.\\n  uint256 public immutable fixedMaxUtilization;\\n\\n  /// @notice Scale factor of the floating curve.\\n  uint256 public immutable floatingCurveA;\\n  /// @notice Origin intercept of the floating curve.\\n  int256 public immutable floatingCurveB;\\n  /// @notice Asymptote of the floating curve.\\n  uint256 public immutable floatingMaxUtilization;\\n\\n  constructor(\\n    uint256 fixedCurveA_,\\n    int256 fixedCurveB_,\\n    uint256 fixedMaxUtilization_,\\n    uint256 floatingCurveA_,\\n    int256 floatingCurveB_,\\n    uint256 floatingMaxUtilization_\\n  ) {\\n    fixedCurveA = fixedCurveA_;\\n    fixedCurveB = fixedCurveB_;\\n    fixedMaxUtilization = fixedMaxUtilization_;\\n\\n    floatingCurveA = floatingCurveA_;\\n    floatingCurveB = floatingCurveB_;\\n    floatingMaxUtilization = floatingMaxUtilization_;\\n\\n    // reverts if it's an invalid curve (such as one yielding a negative interest rate).\\n    fixedRate(0, 0);\\n    floatingRate(0, 0);\\n  }\\n\\n  /// @notice Gets the rate to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate\\n  /// pool and assets from the backup supplier.\\n  /// @param maturity maturity date for calculating days left to maturity.\\n  /// @param amount the current borrow's amount.\\n  /// @param borrowed ex-ante amount borrowed from this fixed rate pool.\\n  /// @param supplied deposits in the fixed rate pool.\\n  /// @param backupAssets backup supplier assets.\\n  /// @return rate of the fee that the borrower will have to pay (represented with 18 decimals).\\n  function fixedBorrowRate(\\n    uint256 maturity,\\n    uint256 amount,\\n    uint256 borrowed,\\n    uint256 supplied,\\n    uint256 backupAssets\\n  ) external view returns (uint256) {\\n    if (block.timestamp >= maturity) revert AlreadyMatured();\\n\\n    uint256 potentialAssets = supplied + backupAssets;\\n    uint256 utilizationAfter = (borrowed + amount).divWadUp(potentialAssets);\\n\\n    if (utilizationAfter > 1e18) revert UtilizationExceeded();\\n\\n    uint256 utilizationBefore = borrowed.divWadDown(potentialAssets);\\n\\n    return fixedRate(utilizationBefore, utilizationAfter).mulDivDown(maturity - block.timestamp, 365 days);\\n  }\\n\\n  /// @notice Returns the interest rate integral from utilizationBefore to utilizationAfter.\\n  /// @dev Minimum and maximum checks to avoid negative rate.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function floatingBorrowRate(uint256 utilizationBefore, uint256 utilizationAfter) external view returns (uint256) {\\n    if (utilizationAfter > 1e18) revert UtilizationExceeded();\\n\\n    return floatingRate(Math.min(utilizationBefore, utilizationAfter), Math.max(utilizationBefore, utilizationAfter));\\n  }\\n\\n  /// @notice Returns the interest rate integral from `u0` to `u1`, using the analytical solution (ln).\\n  /// @dev Uses the fixed rate curve parameters.\\n  /// Handles special case where delta utilization tends to zero, using simpson's rule.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function fixedRate(uint256 utilizationBefore, uint256 utilizationAfter) internal view returns (uint256) {\\n    uint256 alpha = fixedMaxUtilization - utilizationBefore;\\n    uint256 delta = utilizationAfter - utilizationBefore;\\n    int256 r = int256(\\n      delta.divWadDown(alpha) < PRECISION_THRESHOLD\\n        ? (fixedCurveA.divWadDown(alpha) +\\n          fixedCurveA.mulDivDown(4e18, fixedMaxUtilization - ((utilizationAfter + utilizationBefore) / 2)) +\\n          fixedCurveA.divWadDown(fixedMaxUtilization - utilizationAfter)) / 6\\n        : fixedCurveA.mulDivDown(\\n          uint256(int256(alpha.divWadDown(fixedMaxUtilization - utilizationAfter)).lnWad()),\\n          delta\\n        )\\n    ) + fixedCurveB;\\n    assert(r >= 0);\\n    return uint256(r);\\n  }\\n\\n  /// @notice Returns the interest rate integral from `u0` to `u1`, using the analytical solution (ln).\\n  /// @dev Uses the floating rate curve parameters.\\n  /// Handles special case where delta utilization tends to zero, using simpson's rule.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function floatingRate(uint256 utilizationBefore, uint256 utilizationAfter) internal view returns (uint256) {\\n    uint256 alpha = floatingMaxUtilization - utilizationBefore;\\n    uint256 delta = utilizationAfter - utilizationBefore;\\n    int256 r = int256(\\n      delta.divWadDown(alpha) < PRECISION_THRESHOLD\\n        ? (floatingCurveA.divWadDown(alpha) +\\n          floatingCurveA.mulDivDown(4e18, floatingMaxUtilization - ((utilizationAfter + utilizationBefore) / 2)) +\\n          floatingCurveA.divWadDown(floatingMaxUtilization - utilizationAfter)) / 6\\n        : floatingCurveA.mulDivDown(\\n          uint256(int256(alpha.divWadDown(floatingMaxUtilization - utilizationAfter)).lnWad()),\\n          delta\\n        )\\n    ) + floatingCurveB;\\n    assert(r >= 0);\\n    return uint256(r);\\n  }\\n}\\n\\nerror AlreadyMatured();\\nerror UtilizationExceeded();\\n\",\"keccak256\":\"0xb8068f84593a3913e67c7ce154cf985a5a7af95e0ee151e92c54d706aa5f4972\",\"license\":\"BUSL-1.1\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x622fcd8a49e132df5ec7651cc6ae3aaf0cf59bdcd67a9a804a1b9e2485113b7d\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101406040523480156200001257600080fd5b5060405162001295380380620012958339810160408190526200003591620005f6565b608086905260a085905260c084905260e0839052610100829052610120819052620000626000806200007d565b506200007060008062000218565b50505050505050620006e7565b6000808360c05162000090919062000657565b90506000620000a0858562000657565b9050600060a0516602aa1efb94e000620000c985856200033b60201b620002ae1790919060201c565b1062000130576200012a62000111620001008860c051620000eb919062000657565b876200033b60201b620002ae1790919060201c565b6200035960201b620002c31760201c565b846080516200053660201b620004a3179092919060201c565b620001eb565b60066200015d8760c05162000146919062000657565b6080516200033b60201b620002ae1790919060201c565b620001ab673782dace9d9000006002620001788c8c6200066d565b62000184919062000683565b60c05162000193919062000657565b6080516200053660201b620004a3179092919060201c565b620001c7876080516200033b60201b620002ae1790919060201c565b620001d391906200066d565b620001df91906200066d565b620001eb919062000683565b620001f79190620006a6565b905060008112156200020d576200020d620006d1565b925050505b92915050565b60008083610120516200022c919062000657565b905060006200023c858562000657565b90506000610100516602aa1efb94e0006200026685856200033b60201b620002ae1790919060201c565b10620002a2576200012a62000289620001008861012051620000eb919062000657565b8460e0516200053660201b620004a3179092919060201c565b6006620002d08761012051620002b9919062000657565b60e0516200033b60201b620002ae1790919060201c565b6200031f673782dace9d9000006002620002eb8c8c6200066d565b620002f7919062000683565b6101205162000307919062000657565b60e0516200053660201b620004a3179092919060201c565b620001c78760e0516200033b60201b620002ae1790919060201c565b60006200035283670de0b6b3a76400008462000536565b9392505050565b60008082136200039c5760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064015b60405180910390fd5b60006060620003ab8462000556565b03609f8181039490941b90931c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd190190910260016c0504a838426634cdd8738f543560611b03190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b393909302929092017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b8282028115158415858304851417166200054f57600080fd5b0492915050565b6000808211620005955760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b604482015260640162000393565b5060016001600160801b03821160071b82811c6001600160401b031060061b1782811c63ffffffff1060051b1782811c61ffff1060041b1782811c60ff10600390811b90911783811c600f1060021b1783811c909110821b1791821c111790565b60008060008060008060c087890312156200061057600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b634e487b7160e01b600052601160045260246000fd5b8181038181111562000212576200021262000641565b8082018082111562000212576200021262000641565b600082620006a157634e487b7160e01b600052601260045260246000fd5b500490565b8082018281126000831280158216821582161715620006c957620006c962000641565b505092915050565b634e487b7160e01b600052600160045260246000fd5b60805160a05160c05160e0516101005161012051610ae3620007b260003960008181610140015281816107210152818161079e015281816107f5015261086801526000818160cb0152610759015260008181610119015281816107c40152818161081b0152818161088e01526108b90152600081816092015281816104e00152818161055d015281816105c5015261063801526000818161017a015261051801526000818160f20152818161058f015281816105eb0152818161065e01526106890152610ae36000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063d83726851161005b578063d83726851461013b578063df635f3d14610162578063dfb08e1014610175578063fdb9d1f01461019c57600080fd5b80630481520b1461008d57806326980121146100c65780634d6fc522146100ed578063b996993414610114575b600080fd5b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b60405190815260200160405180910390f35b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b46101703660046109b4565b6101af565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b46101aa3660046109ef565b61025e565b60008542106101d1576040516305a29e1160e51b815260040160405180910390fd5b60006101dd8385610a27565b905060006101f5826101ef8989610a27565b906104c2565b9050670de0b6b3a7640000811115610220576040516386a8c2bd60e01b815260040160405180910390fd5b600061022c87846102ae565b905061025161023b428b610a3a565b6301e1338061024a84866104d7565b91906104a3565b9998505050505050505050565b6000670de0b6b3a7640000821115610289576040516386a8c2bd60e01b815260040160405180910390fd5b6102a561029684846106f2565b6102a08585610708565b610718565b90505b92915050565b60006102a583670de0b6b3a7640000846104a3565b60008082136103055760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064015b60405180910390fd5b60006060610312846108de565b03609f8181039490941b90931c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b393909302929092017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b8282028115158415858304851417166104bb57600080fd5b0492915050565b60006102a583670de0b6b3a764000084610986565b600080610504847f0000000000000000000000000000000000000000000000000000000000000000610a3a565b905060006105128585610a3a565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e00061054984866102ae565b106105ba576105b561058d610588610581897f0000000000000000000000000000000000000000000000000000000000000000610a3a565b87906102ae565b6102c3565b7f000000000000000000000000000000000000000000000000000000000000000090856104a3565b6106cc565b60066106106105e9887f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f0000000000000000000000000000000000000000000000000000000000000000906102ae565b610684673782dace9d90000060026106288c8c610a27565b6106329190610a4d565b61065c907f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f000000000000000000000000000000000000000000000000000000000000000091906104a3565b6106ae7f0000000000000000000000000000000000000000000000000000000000000000886102ae565b6106b89190610a27565b6106c29190610a27565b6106cc9190610a4d565b6106d69190610a6f565b905060008112156106e9576106e9610a97565b95945050505050565b600081831061070157816102a5565b5090919050565b60008183101561070157816102a5565b600080610745847f0000000000000000000000000000000000000000000000000000000000000000610a3a565b905060006107538585610a3a565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e00061078a84866102ae565b106107ea576105b56107c2610588610581897f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f000000000000000000000000000000000000000000000000000000000000000090856104a3565b6006610840610819887f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f0000000000000000000000000000000000000000000000000000000000000000906102ae565b6108b4673782dace9d90000060026108588c8c610a27565b6108629190610a4d565b61088c907f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f000000000000000000000000000000000000000000000000000000000000000091906104a3565b6106ae7f0000000000000000000000000000000000000000000000000000000000000000886102ae565b600080821161091b5760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064016102fc565b5060016fffffffffffffffffffffffffffffffff821160071b82811c67ffffffffffffffff1060061b1782811c63ffffffff1060051b1782811c61ffff1060041b1782811c60ff10600390811b90911783811c600f1060021b1783811c909110821b1791821c111790565b82820281151584158583048514171661099e57600080fd5b6001826001830304018115150290509392505050565b600080600080600060a086880312156109cc57600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008060408385031215610a0257600080fd5b50508035926020909101359150565b634e487b7160e01b600052601160045260246000fd5b808201808211156102a8576102a8610a11565b818103818111156102a8576102a8610a11565b600082610a6a57634e487b7160e01b600052601260045260246000fd5b500490565b8082018281126000831280158216821582161715610a8f57610a8f610a11565b505092915050565b634e487b7160e01b600052600160045260246000fdfea26469706673582212209a4354f01757c7e16fc0b97c1c86f456d05e4065d2b06591da9de7b7205275fe64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063d83726851161005b578063d83726851461013b578063df635f3d14610162578063dfb08e1014610175578063fdb9d1f01461019c57600080fd5b80630481520b1461008d57806326980121146100c65780634d6fc522146100ed578063b996993414610114575b600080fd5b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b60405190815260200160405180910390f35b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b46101703660046109b4565b6101af565b6100b47f000000000000000000000000000000000000000000000000000000000000000081565b6100b46101aa3660046109ef565b61025e565b60008542106101d1576040516305a29e1160e51b815260040160405180910390fd5b60006101dd8385610a27565b905060006101f5826101ef8989610a27565b906104c2565b9050670de0b6b3a7640000811115610220576040516386a8c2bd60e01b815260040160405180910390fd5b600061022c87846102ae565b905061025161023b428b610a3a565b6301e1338061024a84866104d7565b91906104a3565b9998505050505050505050565b6000670de0b6b3a7640000821115610289576040516386a8c2bd60e01b815260040160405180910390fd5b6102a561029684846106f2565b6102a08585610708565b610718565b90505b92915050565b60006102a583670de0b6b3a7640000846104a3565b60008082136103055760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064015b60405180910390fd5b60006060610312846108de565b03609f8181039490941b90931c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b393909302929092017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b8282028115158415858304851417166104bb57600080fd5b0492915050565b60006102a583670de0b6b3a764000084610986565b600080610504847f0000000000000000000000000000000000000000000000000000000000000000610a3a565b905060006105128585610a3a565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e00061054984866102ae565b106105ba576105b561058d610588610581897f0000000000000000000000000000000000000000000000000000000000000000610a3a565b87906102ae565b6102c3565b7f000000000000000000000000000000000000000000000000000000000000000090856104a3565b6106cc565b60066106106105e9887f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f0000000000000000000000000000000000000000000000000000000000000000906102ae565b610684673782dace9d90000060026106288c8c610a27565b6106329190610a4d565b61065c907f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f000000000000000000000000000000000000000000000000000000000000000091906104a3565b6106ae7f0000000000000000000000000000000000000000000000000000000000000000886102ae565b6106b89190610a27565b6106c29190610a27565b6106cc9190610a4d565b6106d69190610a6f565b905060008112156106e9576106e9610a97565b95945050505050565b600081831061070157816102a5565b5090919050565b60008183101561070157816102a5565b600080610745847f0000000000000000000000000000000000000000000000000000000000000000610a3a565b905060006107538585610a3a565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e00061078a84866102ae565b106107ea576105b56107c2610588610581897f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f000000000000000000000000000000000000000000000000000000000000000090856104a3565b6006610840610819887f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f0000000000000000000000000000000000000000000000000000000000000000906102ae565b6108b4673782dace9d90000060026108588c8c610a27565b6108629190610a4d565b61088c907f0000000000000000000000000000000000000000000000000000000000000000610a3a565b7f000000000000000000000000000000000000000000000000000000000000000091906104a3565b6106ae7f0000000000000000000000000000000000000000000000000000000000000000886102ae565b600080821161091b5760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064016102fc565b5060016fffffffffffffffffffffffffffffffff821160071b82811c67ffffffffffffffff1060061b1782811c63ffffffff1060051b1782811c61ffff1060041b1782811c60ff10600390811b90911783811c600f1060021b1783811c909110821b1791821c111790565b82820281151584158583048514171661099e57600080fd5b6001826001830304018115150290509392505050565b600080600080600060a086880312156109cc57600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008060408385031215610a0257600080fd5b50508035926020909101359150565b634e487b7160e01b600052601160045260246000fd5b808201808211156102a8576102a8610a11565b818103818111156102a8576102a8610a11565b600082610a6a57634e487b7160e01b600052601260045260246000fd5b500490565b8082018281126000831280158216821582161715610a8f57610a8f610a11565b505092915050565b634e487b7160e01b600052600160045260246000fdfea26469706673582212209a4354f01757c7e16fc0b97c1c86f456d05e4065d2b06591da9de7b7205275fe64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)": {
        "params": {
          "amount": "the current borrow's amount.",
          "backupAssets": "backup supplier assets.",
          "borrowed": "ex-ante amount borrowed from this fixed rate pool.",
          "maturity": "maturity date for calculating days left to maturity.",
          "supplied": "deposits in the fixed rate pool."
        },
        "returns": {
          "_0": "rate of the fee that the borrower will have to pay (represented with 18 decimals)."
        }
      },
      "floatingBorrowRate(uint256,uint256)": {
        "details": "Minimum and maximum checks to avoid negative rate.",
        "params": {
          "utilizationAfter": "ex-post utilization rate, with 18 decimals precision.",
          "utilizationBefore": "ex-ante utilization rate, with 18 decimals precision."
        },
        "returns": {
          "_0": "the interest rate, with 18 decimals precision."
        }
      }
    },
    "stateVariables": {
      "PRECISION_THRESHOLD": {
        "details": "When `eta` (`delta / alpha`) is lower than this value, use simpson's rule for approximation."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)": {
        "notice": "Gets the rate to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate pool and assets from the backup supplier."
      },
      "fixedCurveA()": {
        "notice": "Scale factor of the fixed curve."
      },
      "fixedCurveB()": {
        "notice": "Origin intercept of the fixed curve."
      },
      "fixedMaxUtilization()": {
        "notice": "Asymptote of the fixed curve."
      },
      "floatingBorrowRate(uint256,uint256)": {
        "notice": "Returns the interest rate integral from utilizationBefore to utilizationAfter."
      },
      "floatingCurveA()": {
        "notice": "Scale factor of the floating curve."
      },
      "floatingCurveB()": {
        "notice": "Origin intercept of the floating curve."
      },
      "floatingMaxUtilization()": {
        "notice": "Asymptote of the floating curve."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}