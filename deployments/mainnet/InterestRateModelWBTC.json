{
  "address": "0xC91DC7A797cd5FBCf6F334C792a2b24EFf55292C",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fixedCurveA_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "fixedCurveB_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "fixedMaxUtilization_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "floatingCurveA_",
          "type": "uint256"
        },
        {
          "internalType": "int256",
          "name": "floatingCurveB_",
          "type": "int256"
        },
        {
          "internalType": "uint256",
          "name": "floatingMaxUtilization_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyMatured",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UtilizationExceeded",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "maturity",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "borrowed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "supplied",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "backupAssets",
          "type": "uint256"
        }
      ],
      "name": "fixedBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedCurveA",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedCurveB",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "fixedMaxUtilization",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "utilizationBefore",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "utilizationAfter",
          "type": "uint256"
        }
      ],
      "name": "floatingBorrowRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "floatingCurveA",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "floatingCurveB",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "floatingMaxUtilization",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "borrowed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "supplied",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "backupAssets",
          "type": "uint256"
        }
      ],
      "name": "minFixedRate",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "rate",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "utilization",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x991bf9436538a9eb56b27e9354c1f4758fc24090a5b0b8e4e241dfd1925b44ec",
  "receipt": {
    "to": null,
    "from": "0xe61Bdef3FFF4C3CF7A07996DCB8802b5C85B665a",
    "contractAddress": "0xC91DC7A797cd5FBCf6F334C792a2b24EFf55292C",
    "transactionIndex": 82,
    "gasUsed": "711226",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x2b3e9bf45d316f5c8c6e326c18edb595d983244cfd37f00741a720a37fed54f4",
    "transactionHash": "0x991bf9436538a9eb56b27e9354c1f4758fc24090a5b0b8e4e241dfd1925b44ec",
    "logs": [],
    "blockNumber": 16000512,
    "cumulativeGasUsed": "8182888",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "346800000000000000",
    "-341700000000000000",
    "1000300000000000000",
    "43800000000000000",
    "-33000000000000000",
    "1017300000000000000"
  ],
  "numDeployments": 2,
  "solcInputHash": "097a4f15e656ba3036603e36d961b780",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fixedCurveA_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"fixedCurveB_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"fixedMaxUtilization_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"floatingCurveA_\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"floatingCurveB_\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"floatingMaxUtilization_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyMatured\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UtilizationExceeded\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"backupAssets\",\"type\":\"uint256\"}],\"name\":\"fixedBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedCurveA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedCurveB\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fixedMaxUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"utilizationBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationAfter\",\"type\":\"uint256\"}],\"name\":\"floatingBorrowRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floatingCurveA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floatingCurveB\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"floatingMaxUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"borrowed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplied\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"backupAssets\",\"type\":\"uint256\"}],\"name\":\"minFixedRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)\":{\"params\":{\"amount\":\"the current borrow's amount.\",\"backupAssets\":\"backup supplier assets.\",\"borrowed\":\"ex-ante amount borrowed from this fixed rate pool.\",\"maturity\":\"maturity date for calculating days left to maturity.\",\"supplied\":\"deposits in the fixed rate pool.\"},\"returns\":{\"_0\":\"rate of the fee that the borrower will have to pay (represented with 18 decimals).\"}},\"floatingBorrowRate(uint256,uint256)\":{\"details\":\"Minimum and maximum checks to avoid negative rate.\",\"params\":{\"utilizationAfter\":\"ex-post utilization rate, with 18 decimals precision.\",\"utilizationBefore\":\"ex-ante utilization rate, with 18 decimals precision.\"},\"returns\":{\"_0\":\"the interest rate, with 18 decimals precision.\"}},\"minFixedRate(uint256,uint256,uint256)\":{\"params\":{\"backupAssets\":\"backup supplier assets.\",\"borrowed\":\"amount borrowed from the fixed rate pool.\",\"supplied\":\"deposits in the fixed rate pool.\"},\"returns\":{\"rate\":\"of the fee that the borrower will have to pay and current utilization.\"}}},\"stateVariables\":{\"PRECISION_THRESHOLD\":{\"details\":\"When `eta` (`delta / alpha`) is lower than this value, use simpson's rule for approximation.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)\":{\"notice\":\"Gets the rate to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate pool and assets from the backup supplier.\"},\"fixedCurveA()\":{\"notice\":\"Scale factor of the fixed curve.\"},\"fixedCurveB()\":{\"notice\":\"Origin intercept of the fixed curve.\"},\"fixedMaxUtilization()\":{\"notice\":\"Asymptote of the fixed curve.\"},\"floatingBorrowRate(uint256,uint256)\":{\"notice\":\"Returns the interest rate integral from utilizationBefore to utilizationAfter.\"},\"floatingCurveA()\":{\"notice\":\"Scale factor of the floating curve.\"},\"floatingCurveB()\":{\"notice\":\"Origin intercept of the floating curve.\"},\"floatingMaxUtilization()\":{\"notice\":\"Asymptote of the floating curve.\"},\"minFixedRate(uint256,uint256,uint256)\":{\"notice\":\"Gets the current annualized fixed rate to borrow with supply/demand values in the fixed rate pool and assets from the backup supplier.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/InterestRateModel.sol\":\"InterestRateModel\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`.\\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\\n        // This gives `2**k < a <= 2**(k+1)` \\u2192 `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1;\\n        uint256 x = a;\\n        if (x >> 128 > 0) {\\n            x >>= 128;\\n            result <<= 64;\\n        }\\n        if (x >> 64 > 0) {\\n            x >>= 64;\\n            result <<= 32;\\n        }\\n        if (x >> 32 > 0) {\\n            x >>= 32;\\n            result <<= 16;\\n        }\\n        if (x >> 16 > 0) {\\n            x >>= 16;\\n            result <<= 8;\\n        }\\n        if (x >> 8 > 0) {\\n            x >>= 8;\\n            result <<= 4;\\n        }\\n        if (x >> 4 > 0) {\\n            x >>= 4;\\n            result <<= 2;\\n        }\\n        if (x >> 2 > 0) {\\n            result <<= 1;\\n        }\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = sqrt(a);\\n        if (rounding == Rounding.Up && result * result < a) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xd15c3e400531f00203839159b2b8e7209c5158b35618f570c695b7e47f12e9f0\",\"license\":\"MIT\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport { Math } from \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport { FixedPointMathLib } from \\\"solmate/src/utils/FixedPointMathLib.sol\\\";\\n\\ncontract InterestRateModel {\\n  using FixedPointMathLib for uint256;\\n  using FixedPointMathLib for int256;\\n\\n  /// @notice Threshold to define which method should be used to calculate the interest rates.\\n  /// @dev When `eta` (`delta / alpha`) is lower than this value, use simpson's rule for approximation.\\n  uint256 internal constant PRECISION_THRESHOLD = 7.5e14;\\n\\n  /// @notice Scale factor of the fixed curve.\\n  uint256 public immutable fixedCurveA;\\n  /// @notice Origin intercept of the fixed curve.\\n  int256 public immutable fixedCurveB;\\n  /// @notice Asymptote of the fixed curve.\\n  uint256 public immutable fixedMaxUtilization;\\n\\n  /// @notice Scale factor of the floating curve.\\n  uint256 public immutable floatingCurveA;\\n  /// @notice Origin intercept of the floating curve.\\n  int256 public immutable floatingCurveB;\\n  /// @notice Asymptote of the floating curve.\\n  uint256 public immutable floatingMaxUtilization;\\n\\n  constructor(\\n    uint256 fixedCurveA_,\\n    int256 fixedCurveB_,\\n    uint256 fixedMaxUtilization_,\\n    uint256 floatingCurveA_,\\n    int256 floatingCurveB_,\\n    uint256 floatingMaxUtilization_\\n  ) {\\n    fixedCurveA = fixedCurveA_;\\n    fixedCurveB = fixedCurveB_;\\n    fixedMaxUtilization = fixedMaxUtilization_;\\n\\n    floatingCurveA = floatingCurveA_;\\n    floatingCurveB = floatingCurveB_;\\n    floatingMaxUtilization = floatingMaxUtilization_;\\n\\n    // reverts if it's an invalid curve (such as one yielding a negative interest rate).\\n    fixedRate(0, 0);\\n    floatingRate(0, 0);\\n  }\\n\\n  /// @notice Gets the rate to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate\\n  /// pool and assets from the backup supplier.\\n  /// @param maturity maturity date for calculating days left to maturity.\\n  /// @param amount the current borrow's amount.\\n  /// @param borrowed ex-ante amount borrowed from this fixed rate pool.\\n  /// @param supplied deposits in the fixed rate pool.\\n  /// @param backupAssets backup supplier assets.\\n  /// @return rate of the fee that the borrower will have to pay (represented with 18 decimals).\\n  function fixedBorrowRate(\\n    uint256 maturity,\\n    uint256 amount,\\n    uint256 borrowed,\\n    uint256 supplied,\\n    uint256 backupAssets\\n  ) external view returns (uint256) {\\n    if (block.timestamp >= maturity) revert AlreadyMatured();\\n\\n    uint256 potentialAssets = supplied + backupAssets;\\n    uint256 utilizationAfter = (borrowed + amount).divWadUp(potentialAssets);\\n\\n    if (utilizationAfter > 1e18) revert UtilizationExceeded();\\n\\n    uint256 utilizationBefore = borrowed.divWadDown(potentialAssets);\\n\\n    return fixedRate(utilizationBefore, utilizationAfter).mulDivDown(maturity - block.timestamp, 365 days);\\n  }\\n\\n  /// @notice Returns the interest rate integral from utilizationBefore to utilizationAfter.\\n  /// @dev Minimum and maximum checks to avoid negative rate.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function floatingBorrowRate(uint256 utilizationBefore, uint256 utilizationAfter) external view returns (uint256) {\\n    if (utilizationAfter > 1e18) revert UtilizationExceeded();\\n\\n    return floatingRate(Math.min(utilizationBefore, utilizationAfter), Math.max(utilizationBefore, utilizationAfter));\\n  }\\n\\n  /// @notice Gets the current annualized fixed rate to borrow with supply/demand values in the fixed rate pool and\\n  /// assets from the backup supplier.\\n  /// @param borrowed amount borrowed from the fixed rate pool.\\n  /// @param supplied deposits in the fixed rate pool.\\n  /// @param backupAssets backup supplier assets.\\n  /// @return rate of the fee that the borrower will have to pay and current utilization.\\n  function minFixedRate(\\n    uint256 borrowed,\\n    uint256 supplied,\\n    uint256 backupAssets\\n  ) external view returns (uint256 rate, uint256 utilization) {\\n    utilization = borrowed.divWadUp(supplied + backupAssets);\\n    rate = fixedRate(utilization, utilization);\\n  }\\n\\n  /// @notice Returns the interest rate integral from `u0` to `u1`, using the analytical solution (ln).\\n  /// @dev Uses the fixed rate curve parameters.\\n  /// Handles special case where delta utilization tends to zero, using simpson's rule.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function fixedRate(uint256 utilizationBefore, uint256 utilizationAfter) internal view returns (uint256) {\\n    uint256 alpha = fixedMaxUtilization - utilizationBefore;\\n    uint256 delta = utilizationAfter - utilizationBefore;\\n    int256 r = int256(\\n      delta.divWadDown(alpha) < PRECISION_THRESHOLD\\n        ? (fixedCurveA.divWadDown(alpha) +\\n          fixedCurveA.mulDivDown(4e18, fixedMaxUtilization - ((utilizationAfter + utilizationBefore) / 2)) +\\n          fixedCurveA.divWadDown(fixedMaxUtilization - utilizationAfter)) / 6\\n        : fixedCurveA.mulDivDown(\\n          uint256(int256(alpha.divWadDown(fixedMaxUtilization - utilizationAfter)).lnWad()),\\n          delta\\n        )\\n    ) + fixedCurveB;\\n    assert(r >= 0);\\n    return uint256(r);\\n  }\\n\\n  /// @notice Returns the interest rate integral from `u0` to `u1`, using the analytical solution (ln).\\n  /// @dev Uses the floating rate curve parameters.\\n  /// Handles special case where delta utilization tends to zero, using simpson's rule.\\n  /// @param utilizationBefore ex-ante utilization rate, with 18 decimals precision.\\n  /// @param utilizationAfter ex-post utilization rate, with 18 decimals precision.\\n  /// @return the interest rate, with 18 decimals precision.\\n  function floatingRate(uint256 utilizationBefore, uint256 utilizationAfter) internal view returns (uint256) {\\n    uint256 alpha = floatingMaxUtilization - utilizationBefore;\\n    uint256 delta = utilizationAfter - utilizationBefore;\\n    int256 r = int256(\\n      delta.divWadDown(alpha) < PRECISION_THRESHOLD\\n        ? (floatingCurveA.divWadDown(alpha) +\\n          floatingCurveA.mulDivDown(4e18, floatingMaxUtilization - ((utilizationAfter + utilizationBefore) / 2)) +\\n          floatingCurveA.divWadDown(floatingMaxUtilization - utilizationAfter)) / 6\\n        : floatingCurveA.mulDivDown(\\n          uint256(int256(alpha.divWadDown(floatingMaxUtilization - utilizationAfter)).lnWad()),\\n          delta\\n        )\\n    ) + floatingCurveB;\\n    assert(r >= 0);\\n    return uint256(r);\\n  }\\n}\\n\\nerror AlreadyMatured();\\nerror UtilizationExceeded();\\n\",\"keccak256\":\"0x6eacaa2ccbe2f76ae161c80f0d736a1227720566d2d38a61a9b1ddbf05dbfb74\",\"license\":\"BUSL-1.1\"},\"solmate/src/utils/FixedPointMathLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*//////////////////////////////////////////////////////////////\\n                    SIMPLIFIED FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\\n\\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\\n    }\\n\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\\n    }\\n\\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\\n    }\\n\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\\n    }\\n\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Equivalent to x to the power of y because x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)\\n        return expWad((lnWad(x) * y) / int256(WAD)); // Using ln(x) means x must be greater than 0.\\n    }\\n\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return 0;\\n\\n            // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n            // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n            if (x >= 135305999368893231589) revert(\\\"EXP_OVERFLOW\\\");\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5**18;\\n\\n            // Reduce range of x to (-\\u00bd ln 2, \\u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2**95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            require(x > 0, \\\"UNDEFINED\\\");\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            int256 k = int256(log2(uint256(x))) - 96;\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                    LOW LEVEL FIXED POINT OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n\\n    function rpow(\\n        uint256 x,\\n        uint256 n,\\n        uint256 scalar\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            switch x\\n            case 0 {\\n                switch n\\n                case 0 {\\n                    // 0 ** 0 = 1\\n                    z := scalar\\n                }\\n                default {\\n                    // 0 ** n = 0\\n                    z := 0\\n                }\\n            }\\n            default {\\n                switch mod(n, 2)\\n                case 0 {\\n                    // If n is even, store scalar in z for now.\\n                    z := scalar\\n                }\\n                default {\\n                    // If n is odd, store x in z for now.\\n                    z := x\\n                }\\n\\n                // Shifting right by 1 is like dividing by 2.\\n                let half := shr(1, scalar)\\n\\n                for {\\n                    // Shift n right by 1 before looping to halve it.\\n                    n := shr(1, n)\\n                } n {\\n                    // Shift n right by 1 each iteration to halve it.\\n                    n := shr(1, n)\\n                } {\\n                    // Revert immediately if x ** 2 would overflow.\\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\\n                    if shr(128, x) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Store x squared.\\n                    let xx := mul(x, x)\\n\\n                    // Round to the nearest number.\\n                    let xxRound := add(xx, half)\\n\\n                    // Revert if xx + half overflowed.\\n                    if lt(xxRound, xx) {\\n                        revert(0, 0)\\n                    }\\n\\n                    // Set x to scaled xxRound.\\n                    x := div(xxRound, scalar)\\n\\n                    // If n is even:\\n                    if mod(n, 2) {\\n                        // Compute z * x.\\n                        let zx := mul(z, x)\\n\\n                        // If z * x overflowed:\\n                        if iszero(eq(div(zx, x), z)) {\\n                            // Revert if x is non-zero.\\n                            if iszero(iszero(x)) {\\n                                revert(0, 0)\\n                            }\\n                        }\\n\\n                        // Round to the nearest number.\\n                        let zxRound := add(zx, half)\\n\\n                        // Revert if zx + half overflowed.\\n                        if lt(zxRound, zx) {\\n                            revert(0, 0)\\n                        }\\n\\n                        // Return properly scaled zxRound.\\n                        z := div(zxRound, scalar)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        GENERAL NUMBER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        assembly {\\n            let y := x // We start y at x, which will help us make our initial estimate.\\n\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // We check y >= 2^(k + 8) but shift right by k bits\\n            // each branch to ensure that if x >= 256, then y >= 256.\\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\\n                y := shr(128, y)\\n                z := shl(64, z)\\n            }\\n            if iszero(lt(y, 0x1000000000000000000)) {\\n                y := shr(64, y)\\n                z := shl(32, z)\\n            }\\n            if iszero(lt(y, 0x10000000000)) {\\n                y := shr(32, y)\\n                z := shl(16, z)\\n            }\\n            if iszero(lt(y, 0x1000000)) {\\n                y := shr(16, y)\\n                z := shl(8, z)\\n            }\\n\\n            // Goal was to get z*z*y within a small factor of x. More iterations could\\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\\n\\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\\n\\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\\n\\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\\n\\n            // There is no overflow risk here since y < 2^136 after the first branch above.\\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If x+1 is a perfect square, the Babylonian method cycles between\\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        require(x > 0, \\\"UNDEFINED\\\");\\n\\n        assembly {\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            r := or(r, shl(2, lt(0xf, shr(r, x))))\\n            r := or(r, shl(1, lt(0x3, shr(r, x))))\\n            r := or(r, lt(0x1, shr(r, x)))\\n        }\\n    }\\n\\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // z will equal 0 if y is 0, unlike in Solidity where it will revert.\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Will return 0 instead of reverting if y is zero.\\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        assembly {\\n            // Add 1 to x * y if x % y > 0.\\n            z := add(gt(mod(x, y), 0), div(x, y))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0bf1d4f3999a4471e0fded0a2f67e7fe328e2a27385348571b1fc0a8d9c9f62e\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6101406040523480156200001257600080fd5b5060405162001322380380620013228339810160408190526200003591620005f6565b608086905260a085905260c084905260e0839052610100829052610120819052620000626000806200007d565b506200007060008062000218565b50505050505050620006e7565b6000808360c05162000090919062000657565b90506000620000a0858562000657565b9050600060a0516602aa1efb94e000620000c985856200033b60201b6200030f1790919060201c565b1062000130576200012a62000111620001008860c051620000eb919062000657565b876200033b60201b6200030f1790919060201c565b6200035960201b620003241760201c565b846080516200053660201b62000504179092919060201c565b620001eb565b60066200015d8760c05162000146919062000657565b6080516200033b60201b6200030f1790919060201c565b620001ab673782dace9d9000006002620001788c8c6200066d565b62000184919062000683565b60c05162000193919062000657565b6080516200053660201b62000504179092919060201c565b620001c7876080516200033b60201b6200030f1790919060201c565b620001d391906200066d565b620001df91906200066d565b620001eb919062000683565b620001f79190620006a6565b905060008112156200020d576200020d620006d1565b925050505b92915050565b60008083610120516200022c919062000657565b905060006200023c858562000657565b90506000610100516602aa1efb94e0006200026685856200033b60201b6200030f1790919060201c565b10620002a2576200012a62000289620001008861012051620000eb919062000657565b8460e0516200053660201b62000504179092919060201c565b6006620002d08761012051620002b9919062000657565b60e0516200033b60201b6200030f1790919060201c565b6200031f673782dace9d9000006002620002eb8c8c6200066d565b620002f7919062000683565b6101205162000307919062000657565b60e0516200053660201b62000504179092919060201c565b620001c78760e0516200033b60201b6200030f1790919060201c565b60006200035283670de0b6b3a76400008462000536565b9392505050565b60008082136200039c5760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064015b60405180910390fd5b60006060620003ab8462000556565b03609f8181039490941b90931c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd190190910260016c0504a838426634cdd8738f543560611b03190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b393909302929092017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b8282028115158415858304851417166200054f57600080fd5b0492915050565b6000808211620005955760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b604482015260640162000393565b5060016001600160801b03821160071b82811c6001600160401b031060061b1782811c63ffffffff1060051b1782811c61ffff1060041b1782811c60ff10600390811b90911783811c600f1060021b1783811c909110821b1791821c111790565b60008060008060008060c087890312156200061057600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b634e487b7160e01b600052601160045260246000fd5b8181038181111562000212576200021262000641565b8082018082111562000212576200021262000641565b600082620006a157634e487b7160e01b600052601260045260246000fd5b500490565b8082018281126000831280158216821582161715620006c957620006c962000641565b505092915050565b634e487b7160e01b600052600160045260246000fd5b60805160a05160c05160e0516101005161012051610b70620007b26000396000818161017401528181610782015281816107ff0152818161085601526108c901526000818160d701526107ba01526000818161014d015281816108250152818161087c015281816108ef015261091a015260008181609d01528181610541015281816105be0152818161062601526106990152600081816101ae015261057901526000818160fe015281816105f00152818161064c015281816106bf01526106ea0152610b706000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063b996993411610066578063b996993414610148578063d83726851461016f578063df635f3d14610196578063dfb08e10146101a9578063fdb9d1f0146101d057600080fd5b80630481520b1461009857806326980121146100d25780634d6fc522146100f957806362caa04914610120575b600080fd5b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b61013361012e366004610a15565b6101e3565b604080519283526020830191909152016100c9565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf6101a4366004610a41565b610210565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf6101de366004610a7c565b6102bf565b6000806101fa6101f38486610ab4565b8690610523565b90506102068182610538565b9150935093915050565b6000854210610232576040516305a29e1160e51b815260040160405180910390fd5b600061023e8385610ab4565b90506000610256826102508989610ab4565b90610523565b9050670de0b6b3a7640000811115610281576040516386a8c2bd60e01b815260040160405180910390fd5b600061028d878461030f565b90506102b261029c428b610ac7565b6301e133806102ab8486610538565b9190610504565b9998505050505050505050565b6000670de0b6b3a76400008211156102ea576040516386a8c2bd60e01b815260040160405180910390fd5b6103066102f78484610753565b6103018585610769565b610779565b90505b92915050565b600061030683670de0b6b3a764000084610504565b60008082136103665760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064015b60405180910390fd5b600060606103738461093f565b03609f8181039490941b90931c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b393909302929092017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b82820281151584158583048514171661051c57600080fd5b0492915050565b600061030683670de0b6b3a7640000846109e7565b600080610565847f0000000000000000000000000000000000000000000000000000000000000000610ac7565b905060006105738585610ac7565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e0006105aa848661030f565b1061061b576106166105ee6105e96105e2897f0000000000000000000000000000000000000000000000000000000000000000610ac7565b879061030f565b610324565b7f00000000000000000000000000000000000000000000000000000000000000009085610504565b61072d565b600661067161064a887f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009061030f565b6106e5673782dace9d90000060026106898c8c610ab4565b6106939190610ada565b6106bd907f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009190610504565b61070f7f00000000000000000000000000000000000000000000000000000000000000008861030f565b6107199190610ab4565b6107239190610ab4565b61072d9190610ada565b6107379190610afc565b9050600081121561074a5761074a610b24565b95945050505050565b60008183106107625781610306565b5090919050565b6000818310156107625781610306565b6000806107a6847f0000000000000000000000000000000000000000000000000000000000000000610ac7565b905060006107b48585610ac7565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e0006107eb848661030f565b1061084b576106166108236105e96105e2897f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009085610504565b60066108a161087a887f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009061030f565b610915673782dace9d90000060026108b98c8c610ab4565b6108c39190610ada565b6108ed907f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009190610504565b61070f7f00000000000000000000000000000000000000000000000000000000000000008861030f565b600080821161097c5760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b604482015260640161035d565b5060016fffffffffffffffffffffffffffffffff821160071b82811c67ffffffffffffffff1060061b1782811c63ffffffff1060051b1782811c61ffff1060041b1782811c60ff10600390811b90911783811c600f1060021b1783811c909110821b1791821c111790565b8282028115158415858304851417166109ff57600080fd5b6001826001830304018115150290509392505050565b600080600060608486031215610a2a57600080fd5b505081359360208301359350604090920135919050565b600080600080600060a08688031215610a5957600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008060408385031215610a8f57600080fd5b50508035926020909101359150565b634e487b7160e01b600052601160045260246000fd5b8082018082111561030957610309610a9e565b8181038181111561030957610309610a9e565b600082610af757634e487b7160e01b600052601260045260246000fd5b500490565b8082018281126000831280158216821582161715610b1c57610b1c610a9e565b505092915050565b634e487b7160e01b600052600160045260246000fdfea26469706673582212206a786d9aeaaae22c4937ac0f308cd59729d09151c617e00dc092512097c0e02064736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063b996993411610066578063b996993414610148578063d83726851461016f578063df635f3d14610196578063dfb08e10146101a9578063fdb9d1f0146101d057600080fd5b80630481520b1461009857806326980121146100d25780634d6fc522146100f957806362caa04914610120575b600080fd5b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b61013361012e366004610a15565b6101e3565b604080519283526020830191909152016100c9565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf6101a4366004610a41565b610210565b6100bf7f000000000000000000000000000000000000000000000000000000000000000081565b6100bf6101de366004610a7c565b6102bf565b6000806101fa6101f38486610ab4565b8690610523565b90506102068182610538565b9150935093915050565b6000854210610232576040516305a29e1160e51b815260040160405180910390fd5b600061023e8385610ab4565b90506000610256826102508989610ab4565b90610523565b9050670de0b6b3a7640000811115610281576040516386a8c2bd60e01b815260040160405180910390fd5b600061028d878461030f565b90506102b261029c428b610ac7565b6301e133806102ab8486610538565b9190610504565b9998505050505050505050565b6000670de0b6b3a76400008211156102ea576040516386a8c2bd60e01b815260040160405180910390fd5b6103066102f78484610753565b6103018585610769565b610779565b90505b92915050565b600061030683670de0b6b3a764000084610504565b60008082136103665760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b60448201526064015b60405180910390fd5b600060606103738461093f565b03609f8181039490941b90931c6c465772b2bbbb5f824b15207a3081018102606090811d6d0388eaa27412d5aca026815d636e018202811d6d0df99ac502031bf953eff472fdcc018202811d6d13cdffb29d51d99322bdff5f2211018202811d6d0a0f742023def783a307a986912e018202811d6d01920d8043ca89b5239253284e42018202811d6c0b7a86d7375468fac667a0a527016c29508e458543d8aa4df2abee7883018302821d6d0139601a2efabe717e604cbb4894018302821d6d02247f7a7b6594320649aa03aba1018302821d6c8c3f38e95a6b1ff2ab1c3b343619018302821d6d02384773bdf1ac5676facced60901901830290911d6cb9a025d814b29c212b8b1a07cd1901909102780a09507084cc699bb0e71ea869ffffffffffffffffffffffff190105711340daa0d5f769dba1915cef59f0815a5506027d0267a36c0c95b3975ab3ee5b203a7614a3f75373f047d803ae7b6687f2b393909302929092017d57115e47018c7177eebf7cd370a3356a1b7863008a5ae8028c72b88642840160ae1d92915050565b82820281151584158583048514171661051c57600080fd5b0492915050565b600061030683670de0b6b3a7640000846109e7565b600080610565847f0000000000000000000000000000000000000000000000000000000000000000610ac7565b905060006105738585610ac7565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e0006105aa848661030f565b1061061b576106166105ee6105e96105e2897f0000000000000000000000000000000000000000000000000000000000000000610ac7565b879061030f565b610324565b7f00000000000000000000000000000000000000000000000000000000000000009085610504565b61072d565b600661067161064a887f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009061030f565b6106e5673782dace9d90000060026106898c8c610ab4565b6106939190610ada565b6106bd907f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009190610504565b61070f7f00000000000000000000000000000000000000000000000000000000000000008861030f565b6107199190610ab4565b6107239190610ab4565b61072d9190610ada565b6107379190610afc565b9050600081121561074a5761074a610b24565b95945050505050565b60008183106107625781610306565b5090919050565b6000818310156107625781610306565b6000806107a6847f0000000000000000000000000000000000000000000000000000000000000000610ac7565b905060006107b48585610ac7565b905060007f00000000000000000000000000000000000000000000000000000000000000006602aa1efb94e0006107eb848661030f565b1061084b576106166108236105e96105e2897f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009085610504565b60066108a161087a887f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009061030f565b610915673782dace9d90000060026108b98c8c610ab4565b6108c39190610ada565b6108ed907f0000000000000000000000000000000000000000000000000000000000000000610ac7565b7f00000000000000000000000000000000000000000000000000000000000000009190610504565b61070f7f00000000000000000000000000000000000000000000000000000000000000008861030f565b600080821161097c5760405162461bcd60e51b815260206004820152600960248201526815539111519253915160ba1b604482015260640161035d565b5060016fffffffffffffffffffffffffffffffff821160071b82811c67ffffffffffffffff1060061b1782811c63ffffffff1060051b1782811c61ffff1060041b1782811c60ff10600390811b90911783811c600f1060021b1783811c909110821b1791821c111790565b8282028115158415858304851417166109ff57600080fd5b6001826001830304018115150290509392505050565b600080600060608486031215610a2a57600080fd5b505081359360208301359350604090920135919050565b600080600080600060a08688031215610a5957600080fd5b505083359560208501359550604085013594606081013594506080013592509050565b60008060408385031215610a8f57600080fd5b50508035926020909101359150565b634e487b7160e01b600052601160045260246000fd5b8082018082111561030957610309610a9e565b8181038181111561030957610309610a9e565b600082610af757634e487b7160e01b600052601260045260246000fd5b500490565b8082018281126000831280158216821582161715610b1c57610b1c610a9e565b505092915050565b634e487b7160e01b600052600160045260246000fdfea26469706673582212206a786d9aeaaae22c4937ac0f308cd59729d09151c617e00dc092512097c0e02064736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)": {
        "params": {
          "amount": "the current borrow's amount.",
          "backupAssets": "backup supplier assets.",
          "borrowed": "ex-ante amount borrowed from this fixed rate pool.",
          "maturity": "maturity date for calculating days left to maturity.",
          "supplied": "deposits in the fixed rate pool."
        },
        "returns": {
          "_0": "rate of the fee that the borrower will have to pay (represented with 18 decimals)."
        }
      },
      "floatingBorrowRate(uint256,uint256)": {
        "details": "Minimum and maximum checks to avoid negative rate.",
        "params": {
          "utilizationAfter": "ex-post utilization rate, with 18 decimals precision.",
          "utilizationBefore": "ex-ante utilization rate, with 18 decimals precision."
        },
        "returns": {
          "_0": "the interest rate, with 18 decimals precision."
        }
      },
      "minFixedRate(uint256,uint256,uint256)": {
        "params": {
          "backupAssets": "backup supplier assets.",
          "borrowed": "amount borrowed from the fixed rate pool.",
          "supplied": "deposits in the fixed rate pool."
        },
        "returns": {
          "rate": "of the fee that the borrower will have to pay and current utilization."
        }
      }
    },
    "stateVariables": {
      "PRECISION_THRESHOLD": {
        "details": "When `eta` (`delta / alpha`) is lower than this value, use simpson's rule for approximation."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "fixedBorrowRate(uint256,uint256,uint256,uint256,uint256)": {
        "notice": "Gets the rate to borrow a certain amount at a certain maturity with supply/demand values in the fixed rate pool and assets from the backup supplier."
      },
      "fixedCurveA()": {
        "notice": "Scale factor of the fixed curve."
      },
      "fixedCurveB()": {
        "notice": "Origin intercept of the fixed curve."
      },
      "fixedMaxUtilization()": {
        "notice": "Asymptote of the fixed curve."
      },
      "floatingBorrowRate(uint256,uint256)": {
        "notice": "Returns the interest rate integral from utilizationBefore to utilizationAfter."
      },
      "floatingCurveA()": {
        "notice": "Scale factor of the floating curve."
      },
      "floatingCurveB()": {
        "notice": "Origin intercept of the floating curve."
      },
      "floatingMaxUtilization()": {
        "notice": "Asymptote of the floating curve."
      },
      "minFixedRate(uint256,uint256,uint256)": {
        "notice": "Gets the current annualized fixed rate to borrow with supply/demand values in the fixed rate pool and assets from the backup supplier."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}